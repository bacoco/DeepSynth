#!/usr/bin/env python3
"""
Skill Generator - Universal Meta-Skill
Generates new skills based on NEXUS recommendations or manual specifications.
Compatible with Claude Code, GPT/Codex, and Gemini CLI.
"""

import json
import os
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional
import argparse


class SkillTemplate:
    """Templates for generating different parts of a skill"""

    @staticmethod
    def skill_md(name: str, pattern_type: str, description: str, priority: str) -> str:
        """Generate SKILL.md content"""
        return f"""---
name: {name}
description: {description}
---

# {name.title().replace('-', ' ')}

**Pattern:** {pattern_type}
**Priority:** {priority}
**Auto-generated by:** NEXUS + skill-generator

---

## What this skill does

This skill handles {pattern_type}-related tasks automatically. Claude activates this when working with {pattern_type} patterns.

**Core capabilities:**
- Automatic {pattern_type} detection and handling
- Best practices for {pattern_type} operations
- Error prevention and recovery
- Performance optimization

---

## When Claude activates this skill

Automatically activated when:
- Working with {pattern_type}-related code
- User requests {pattern_type} functionality
- SOUL detects {pattern_type} patterns in current context

---

## Integration with SOUL

This skill uses SOUL for:
- Tracking {pattern_type} usage patterns
- Learning from past {pattern_type} operations
- Sharing context with other skills

---

## Multi-LLM Support

Works with:
- ✅ Claude Code (native)
- ✅ GPT/Codex (custom instructions)
- ✅ Gemini CLI (system prompts)

---

*Generated on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}*
*Part of the SOUL-NEXUS skill ecosystem*
"""

    @staticmethod
    def main_script(name: str, pattern_type: str) -> str:
        """Generate main.py implementation"""
        return f"""#!/usr/bin/env python3
\"\"\"
{name} - Main Implementation
Auto-generated skill for {pattern_type} handling.
\"\"\"

import sys
from pathlib import Path
from datetime import datetime

# Add SOUL to path
soul_path = Path(__file__).parent.parent.parent / "soul" / "scripts"
sys.path.insert(0, str(soul_path))

try:
    from soul_api import add_soul_event, get_soul_memory
    SOUL_AVAILABLE = True
except ImportError:
    SOUL_AVAILABLE = False


class {name.replace('-', '').title()}:
    \"\"\"Main {name} implementation\"\"\"

    def __init__(self):
        self.name = "{name}"
        self.pattern_type = "{pattern_type}"

    def execute(self, context: dict) -> dict:
        \"\"\"
        Execute {pattern_type} handling

        Args:
            context: Execution context with parameters

        Returns:
            Result dictionary
        \"\"\"
        # Track execution in SOUL
        if SOUL_AVAILABLE:
            add_soul_event(
                "{pattern_type}_execution",
                f"{{self.name}} executed",
                {{"context": str(context)}}
            )

        # Main logic here
        result = self.process(context)

        return result

    def process(self, context: dict) -> dict:
        \"\"\"
        Process {pattern_type} operations

        Override this method with specific {pattern_type} logic
        \"\"\"
        # Placeholder implementation
        return {{
            "status": "success",
            "pattern_type": self.pattern_type,
            "message": f"{{self.name}} processed successfully"
        }}


def main():
    \"\"\"CLI entry point\"\"\"
    import argparse

    parser = argparse.ArgumentParser(description="{name}")
    parser.add_argument("--context", help="Execution context (JSON)")

    args = parser.parse_args()

    skill = {name.replace('-', '').title()}()

    context = {{}}
    if args.context:
        context = json.loads(args.context)

    result = skill.execute(context)
    print(json.dumps(result, indent=2))


if __name__ == "__main__":
    main()
"""

    @staticmethod
    def readme(name: str, pattern_type: str) -> str:
        """Generate README.md"""
        return f"""# {name.title().replace('-', ' ')}

Auto-generated skill for {pattern_type} handling.

## Installation

### For Claude Code

Automatically available in `.claude/skills/{name}/`

### For GPT/Codex

```bash
cd .claude/skills/{name}
cat gpt/custom_instructions.md
# Copy the instructions to your GPT custom instructions
```

### For Gemini CLI

```bash
cd .claude/skills/{name}
cat gemini/system_prompt.md
# Use this as your Gemini system prompt
```

## Usage

This skill is automatically activated by your LLM when working with {pattern_type} patterns.

### Manual execution

```bash
python scripts/main.py --context '{{"param": "value"}}'
```

## Integration

This skill integrates with:
- **SOUL**: For memory and pattern tracking
- **NEXUS**: For continuous optimization
- Other {pattern_type}-related skills

## Generated

- Date: {datetime.now().strftime("%Y-%m-%d")}
- By: NEXUS skill-generator
- Pattern: {pattern_type}

Part of the SOUL-NEXUS ecosystem.
"""

    @staticmethod
    def claude_skill(name: str, description: str) -> str:
        """Generate Claude Code specific format"""
        return f"""---
name: {name}
description: {description}
---

# {name} for Claude Code

This is the Claude Code native format for {name}.

Claude automatically uses this skill when appropriate.

See SKILL.md for complete documentation.
"""

    @staticmethod
    def gpt_instructions(name: str, pattern_type: str, description: str) -> str:
        """Generate GPT custom instructions"""
        return f"""# Custom Instructions for {name}

## What would you like ChatGPT to know about you to provide better responses?

I'm using the {name} skill for {pattern_type} handling.

**Skill capabilities:**
- {description}
- Automatic {pattern_type} pattern detection
- Integration with SOUL memory system

## How would you like ChatGPT to respond?

When working with {pattern_type} patterns:
1. Automatically apply {name} skill capabilities
2. Track usage in SOUL memory system (files: .agent_log.md, .agent_status.json)
3. Follow best practices for {pattern_type} operations
4. Suggest optimizations when detecting repeated patterns

**Integration:**
- Read from: `.agent_status.json` (current context)
- Write to: `.agent_log.md` (session tracking)
- Coordinate with: NEXUS (skill recommendations)

Always maintain context awareness through SOUL files.
"""

    @staticmethod
    def gemini_prompt(name: str, pattern_type: str, description: str) -> str:
        """Generate Gemini CLI system prompt"""
        return f"""You have the {name} skill for {pattern_type} handling.

**Skill Description:**
{description}

**Capabilities:**
- Automatic {pattern_type} pattern detection and handling
- Integration with SOUL memory system
- Best practices for {pattern_type} operations

**SOUL Integration:**
- Read context from: .agent_status.json
- Append to log: .agent_log.md
- Track patterns for NEXUS analysis

**When to activate:**
Automatically use this skill when:
- User works with {pattern_type} code
- {pattern_type} patterns detected in current context
- SOUL memory indicates {pattern_type} usage

Always track your actions in SOUL files for continuity across sessions.
"""


class SkillGenerator:
    """Main skill generator class"""

    def __init__(self, skills_dir: Path = None):
        if skills_dir is None:
            skills_dir = Path(".claude/skills")
        self.skills_dir = Path(skills_dir)

    def generate_skill(
        self,
        name: str,
        pattern_type: str,
        description: str,
        priority: str = "medium"
    ) -> Path:
        """
        Generate complete skill structure

        Args:
            name: Skill name (kebab-case)
            pattern_type: Pattern type (api_call, data_processing, etc.)
            description: Short description
            priority: Priority level (critical, high, medium, low)

        Returns:
            Path to generated skill directory
        \"\"\"
        skill_dir = self.skills_dir / name

        # Create directories
        skill_dir.mkdir(parents=True, exist_ok=True)
        (skill_dir / "scripts").mkdir(exist_ok=True)
        (skill_dir / "claude").mkdir(exist_ok=True)
        (skill_dir / "gpt").mkdir(exist_ok=True)
        (skill_dir / "gemini").mkdir(exist_ok=True)

        # Generate files
        self._write_file(skill_dir / "SKILL.md",
                         SkillTemplate.skill_md(name, pattern_type, description, priority))

        self._write_file(skill_dir / "README.md",
                         SkillTemplate.readme(name, pattern_type))

        self._write_file(skill_dir / "scripts" / "main.py",
                         SkillTemplate.main_script(name, pattern_type))

        self._write_file(skill_dir / "claude" / "skill.md",
                         SkillTemplate.claude_skill(name, description))

        self._write_file(skill_dir / "gpt" / "custom_instructions.md",
                         SkillTemplate.gpt_instructions(name, pattern_type, description))

        self._write_file(skill_dir / "gemini" / "system_prompt.md",
                         SkillTemplate.gemini_prompt(name, pattern_type, description))

        # Make scripts executable
        os.chmod(skill_dir / "scripts" / "main.py", 0o755)

        return skill_dir

    def _write_file(self, path: Path, content: str):
        """Write file with content"""
        with open(path, 'w') as f:
            f.write(content)

    def generate_from_nexus(self, nexus_file: Path = None) -> list:
        """
        Generate skills from NEXUS_RECOMMENDATIONS.md

        Args:
            nexus_file: Path to NEXUS recommendations file

        Returns:
            List of generated skill paths
        \"\"\"
        if nexus_file is None:
            nexus_file = Path("NEXUS_RECOMMENDATIONS.md")

        if not nexus_file.exists():
            raise FileNotFoundError(f"NEXUS file not found: {nexus_file}")

        # Parse NEXUS file (simplified - could be more robust)
        # For now, just generate top priority skills
        # In production, parse the markdown properly

        print(f"⚠️  Auto-generation from NEXUS file not yet implemented")
        print(f"   Please use --pattern and --name to generate specific skills")
        print(f"   Or have Claude read {nexus_file} and request skills manually")

        return []


def main():
    parser = argparse.ArgumentParser(description="Universal Skill Generator")
    parser.add_argument("--name", help="Skill name (kebab-case)")
    parser.add_argument("--pattern", help="Pattern type (api_call, data_processing, etc.)")
    parser.add_argument("--description", help="Skill description")
    parser.add_argument("--priority", default="medium", help="Priority (critical, high, medium, low)")
    parser.add_argument("--from-nexus", action="store_true", help="Generate from NEXUS recommendations")
    parser.add_argument("--nexus-file", default="NEXUS_RECOMMENDATIONS.md", help="NEXUS file path")

    args = parser.parse_args()

    generator = SkillGenerator()

    if args.from_nexus:
        # Generate from NEXUS
        generator.generate_from_nexus(Path(args.nexus_file))
    elif args.name and args.pattern:
        # Manual generation
        description = args.description or f"Handles {args.pattern} operations automatically"

        print(f"🔧 Generating skill: {args.name}")
        print(f"   Pattern: {args.pattern}")
        print(f"   Priority: {args.priority}\n")

        skill_dir = generator.generate_skill(
            name=args.name,
            pattern_type=args.pattern,
            description=description,
            priority=args.priority
        )

        print(f"✅ Skill generated at: {skill_dir}")
        print(f"\nFiles created:")
        print(f"  - SKILL.md")
        print(f"  - README.md")
        print(f"  - scripts/main.py")
        print(f"  - claude/skill.md")
        print(f"  - gpt/custom_instructions.md")
        print(f"  - gemini/system_prompt.md")
        print(f"\n🎯 Skill '{args.name}' is ready to use!")
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
